# 五分鐘讓你讀懂最佳化
##### tags:`課程` `最佳化` `中平`

## 2017 Fall Final
### 1. Modified nodal analysis
![](https://i.imgur.com/8ThIaMN.png)


## 2017 Fall
### 1. Nodal analysis
#### Derive NA for the following circuit, all the voltage and resistance value is 1.
![](https://i.imgur.com/uDgnY9Y.png)


#### (a) (5%) Briefly describe how the G matrix and I come from such that “GV = I”.
用柯西和夫定律，所有流出節點的電流和為零的性質，列出節點數量的方程式再寫成矩陣的形式。

#### (b) (10%) Find out the nodal voltage of Vx using NA(Nodal Analysis) and implement it.
```
G = [4 -1 0 0 -1;
    -1 3 -1 0 -1;
    0 -1 2 -1 0;
    0 0 -1 3 -1;
    -1 -1 0 -1 3;];
I = [1 0 0 0 0]';
V = inv(G) * I;
V(5)
```

#### \(c\) (10%) Using LTspice to generate the circuit and export the voltage data. Print the exported voltage at arbitrary time to show that the results are the same. *Files to commit: P1.m & P1.asc (Should contain a txt file from LTspice with any name.
![](https://i.imgur.com/1frjR0c.png)

### 2. MNA (Modified Nodal Analysis)
#### Let (G+sC)V=I. Derive MNA for the following circuit with all the values of voltage source,resistances and capacitances are 1.

#### (a) ( 5%) Using eigen method to derive the form of V. (Hint: Using eigen decomposition to decompose G^-1^C).
公式(eigen decomposition):

$$
\begin{align}
(\mathbf{G}+s\mathbf{C}) \mathbf{V} &= \mathbf{I_s} \\
(\mathbf{I}+s\mathbf{G^\mathrm{-1}}\mathbf{C})\mathbf{V} &= \mathbf{G^\mathrm{-1}} \cdot \mathbf{I_s} \\
(\mathbf{W} \mathbf{W^\mathrm{-1}}+s \mathbf{W} \mathbf{\Lambda} \mathbf{W^\mathrm{-1}})\mathbf{V} &= \mathbf{G^\mathrm{-1}} \cdot \mathbf{I_s} \\
\mathbf{V} &= \mathbf{W}(\mathbf{I}+s\mathbf{\Lambda})^\mathrm{-1}\mathbf{W^\mathrm{-1}} \mathbf{G^\mathrm{-1}}\mathbf{I_s}
\end{align}
$$

#### (b) (10%) Implement matlab code to find out Vx using Laplace transformation.
![](https://i.imgur.com/sM5fx4o.png)

#### \(c\) (10%) Using LTspice to generate the circuit and export the voltage data. Put two V-t curves on the same figure. (Hint: Using same step size and same duration so as to make two curves overlap) *Files to commit: P2.m & P2.asc(Should contain a txt file from LTspice with any name.)
```
G = [2 -1 0 0 0;
    -1 2 0 -1 0;
    0 0 2 -1 -1;
    0 -1 -1 2 0;
    0 0 -1 0 1;];
C = [1 0 0 0 0;
    0 2 -1 0 0;
    0 -1 1 0 0;
    0 0 0 1 -1;
    0 0 0 -1 3;];
syms s
A = inv(G)*C;
[V,D]=eig(A);
I = eye(5);
Id = [1 0 0 0 0]';
Id = Id/s ;
result = V * inv(I+s*D) * inv(V) * inv(G) * Id;
L = ilaplace(result);
%compute by matlab
ezplot(L(5),[0,15,0,1],1); hold on

load P2.txt;
X = P2(:,1);
Y = P2(:,2);
%simulate by LT Spice
plot(X,Y)
```

### 3. Cholesky
#### (a) (10%) Derive the Cholesky decomposition formulae without square root (A = LDL^-1^), write down the general form of L and D.

$$
\begin{align}
\mathbf{A} = \mathbf{LDL}^\mathrm{T} & =
\begin{pmatrix}   1 & 0 & 0 \\
   L_{21} & 1 & 0 \\
   L_{31} & L_{32} & 1\\
\end{pmatrix}
\begin{pmatrix}   D_1 & 0 & 0 \\
   0 & D_2 & 0 \\
   0 & 0 & D_3\\
\end{pmatrix}
\begin{pmatrix}   1 & L_{21} & L_{31} \\
   0 & 1 & L_{32} \\
   0 & 0 & 1\\
\end{pmatrix} \\[8pt]
& = \begin{pmatrix}   D_1 &   &(\mathrm{symmetric})   \\
   L_{21}D_1 & L_{21}^2D_1 + D_2& \\
   L_{31}D_1 & L_{31}L_{21}D_{1}+L_{32}D_2 & L_{31}^2D_1 + L_{32}^2D_2+D_3.
\end{pmatrix}.
\end{align}
$$

如果 $\mathbf{A}$ 是實數矩陣，下述之遞迴計算式適用於矩陣 $\mathbf{D}$ 及 $\mathbf{L}$ 中的所有元素︰ 

$$
\begin{align}
D_j & = A_{jj} - \sum_{k=1}^{j-1} L_{jk}^2 D_k \\
L_{ij} & = \frac{1}{D_j} \left( A_{ij} - \sum_{k=1}^{j-1} L_{ik} L_{jk} D_k \right) \quad \text{for } i>j
\end{align}
$$

#### (b) (15%) Implement this algorithm as a Matlab function.(Note that, Name the function as “LDLT”, which takes an input and generates output pair [LU], I will test it with some cases.) Files to commit: LDLT.m
```
A=[4 -1 1; 
   -1 4.25 2.75;
   1 2.75 16;];
s = length(A);
L=zeros(s,s); 
D=zeros(s,s);
t = 0;
L = L + eye(s);
for j=1:s 
    for i=j:s
        sum0=0
        for k= 1:j-1
            sum0 = sum0+ L(j,k)*L(i,k)*D(k,k);
        end
        if j==i
            D(i,j) =  A(i,j) - sum0 ;
        else
            L(i,j)= (A(i,j)-sum0)/D(j,j);
        end
    end
end
S = L*D*transpose(L)
```




### 補充: Cholesky分解
![](https://i.imgur.com/MnXlxCB.png)
```
% reference: https://www.mathworks.com/matlabcentral/answers/482145-cholesky-decomposition-column-wise-algorithm-implementation
A=[4 -1 1; 
   -1 4.25 2.75;
   1 2.75 16;];
% Check U matches with col(A);
count = 0;
[n,n] = size(A);
U=zeros(n,n)
for j=1:n
    for i=1:j-1
        sum1 = 0
        for k=1:i-1
            sum1 = sum1 + U(k,i)*U(k,j);
        end
        U(i,j)=(A(i,j)-sum1)/U(i,i);
    end
    sum2 = 0;
    for k=1:j-1 
        sum2 = sum2 + U(k,j)*U(k,j);
    end
    U(j,j)=sqrt(A(j,j)-sum2);
end
L=transpose(U);
S=L*U
```
### 補充: LU分解
解A = LU
```
A = [1 2 3; 2 5 7; 3 5 3];  
[m,n] = size(A);
L=zeros(m,m);
U=zeros(m,m);

for i=1:m
  % Finding L
    for k=1:i-1
        L(i,k)=A(i,k);
        for j=1:k-1
            L(i,k)= L(i,k)-L(i,j)*U(j,k);
        end
        L(i,k) = L(i,k)/U(k,k);
    end
  % Finding U
    for k=i:m
        U(i,k) = A(i,k);
        for j=1:i-1
            U(i,k)= U(i,k)-L(i,j)*U(j,k);
        end
    end
end
for i=1:m
    L(i,i)=1;
end
L
U
```

![](https://i.imgur.com/sVqWqMf.png)
![](https://i.imgur.com/cL8R56Y.png)

### 4. The Gram-Schmidt process and QR decomposition
#### Derive QR decomposition based on Gram-Schmidt. 
![](https://i.imgur.com/EwXWd5r.png)
![](https://i.imgur.com/RnAyUY9.png)
![](https://i.imgur.com/UEcuC7Z.png)

```
function [Q,R] = QR(A)
[m,n] = size(A);
Q = zeros(m,m);
R = zeros(m,n);
R1 = zeros(m,n);
for j = 1:m
  
	v = A(:,j);
	for i = 1:j-1
		R1(i,j) = Q(:,i)' * A(:,j);
		v = v - R1(i,j) * Q(:,i);
	end
	R1(j,j) = norm(v);
	Q(:,j) = v / R1(j,j);
end
R = Q' * A; 
end
```

#### QR分解：
找Q使用格拉姆-施密特正交化方法
https://zh.wikipedia.org/zh-tw/QR%E5%88%86%E8%A7%A3

#### 範例
https://www.math.ucla.edu/~yanovsky/Teaching/Math151B/handouts/GramSchmidt.pdf

## 最佳化 11/25
簡易繪圖法： `fplot(matlabFunction(/*Syms Function*/), [Lower, Upper]);`
`hold on`： 維持在同一座標軸上作圖
```
syms s t

g = [1 1 1 1 1 1 1];
c = [1 1 1 1 1 1 1];

G = [g(1)+g(2)+g(5) -g(2) 0 0 -g(5) 0 0;
    -g(2) g(2)+g(3) -g(3) 0 0 0 0;
    0 -g(3) g(3)+g(4) -g(4) 0 0 0;
    0 0 -g(4) g(4) 0 0 0 ;
    -g(5) 0 0 0 g(5)+g(6) -g(6) 0;
    0 0 0 0 -g(6) g(6)+g(7) -g(7);
    0 0 0 0 0 -g(7) g(7);
    ];
C = [c(1) 0 0 0 0 0 0;
    0 c(2)+c(5) 0 0 -c(5) 0 0;
    0 0 c(3)+c(6) 0 0 -c(6) 0;
    0 0 0 c(4)+c(7) 0 0 -c(7);
    0 -c(5) 0 0 c(5) 0 0;
    0 0 -c(6) 0 0 c(6) 0;
    0 0 0 -c(7) 0 0 c(7);
    ];
I_s = [1/s;0;0;0;0;0;0];

[P,D] = eig(G\C);

[m,n] = size(I_s);
V_ans = P*((eye(m)+s*D)\(P\(G\I_s))); % V_ans = P*inv(eye(m)+s*D)*inv(P)*inv(G)*I_s;

V_ans = ilaplace(V_ans);
for i = 1:m
    pretty(vpa(V_ans(i),5))
    fplot(matlabFunction(V_ans(i)), [0,80]);
    if i == 1
        hold on
    end
end
hold off
```

## 2019 Fall
### 1.b
同2017 2(a)
### 1.c
參考韋辰的 code，只有留下使用 `eig` 的作法並且改成使用 `ilaplace`
讀取 LTSpice 檔案的部分也使用 `readtable` -> `table2array` -> 轉置 的方式做簡化
```=
clear all;
close all;
clc;
syms s

simtime = 20;
total_node = 8;
lt_sim_path = 'LT1_c.txt';

C = eye(total_node)*2;
C(1,3) = -1;
C(3,1) = -1;
C(2,4) = -1;
C(4,2) = -1;
C(5,7) = -1;
C(7,5) = -1;
C(6,8) = -1;
C(8,6) = -1;

G = [4 -1 0 0 -1 0 0 0;
    -1 4 0 0 0 -1 0 0;
     0 0 3 -1 0 0 -1 0;
     0 0 -1 3 0 0 0 1;
    -1 0 0 0 3 -1 0 0;
     0 -1 0 0 -1 3 0 0;
     0 0 -1 0 0 0 4 -1;
     0 0 0 -1 0 0 -1 4];

% Eigen
[W, L] = eig(G\C);
I_s = [1/s;1/s;0;0;0;0;0;0];
V_eig = W*((eye(total_node)+s*L)\(W\(G\I_s)));
V_eig = ilaplace(V_eig);

% read LTSpice Simulation Data
V_lt = table2array(readtable(lt_sim_path))';

plot(V_lt(1,:), V_lt(2,:));
hold on
fplot(matlabFunction(V_eig(1)), [0, simtime]);
```
### 3
抄維基的例子就可以說明，往上滑可以找到LU分解的相關性質說明
![](https://i.imgur.com/OlSxDwo.png)


## 2020 洩題
### 第一題
![](https://i.imgur.com/8SUqWyG.png)

```
%syms s Is C V
syms s 
n = 7;
Is = [1/s ; 0; 0; 0; 0; 0; 0];
I = eye(n)

G = [3 -1 0 0 -1 0 0; -1 2 -1 0 0 0 0; 0 -1 2 -1 0 0 0; 0 0 -1 1 0 0 0; -1 0 0 0 2 -1 0; 0 0 0 0 -1 2 -1; 0 0 0 0 0 -1 1]
C = [1 0 0 0 0 0 0 ; 0 2 0 0 -1 0 0; 0 0 2 0 0 -1 0; 0 0 0 2 0 0 -1; 0 -1 0 0 1 0 0; 0 0 -1 0 0 1 0; 0 0 0 -1 0 0 1]
X = G\C

[V,D] = eig(X)
V*D*inv(V)
v = V * inv(I + s*D)*inv(V)*inv(G)*Is;
v
f = ilaplace(v)
h = matlabFunction(f(7));
t = 0:0.01:20;
plot(t,h(t));hold on

load LT_Output_Data.txt; % 更改成你自己的路徑
X = LT_Output_Data(:,1); % 這邊是時間軸
Y = LT_Output_Data(:,3); % 更改成自己要的資料column
%simulate by LT Spice
plot(X,Y)
```
========================


### 第二題

以下程式以這張圖為範例
![](https://i.imgur.com/VxvSouj.png)

```=
%-----------------
row = 4; 
column = 4;
%-----------------
rowNode = row - 1;
columnNode = column +1;
NumOfNode = rowNode * columnNode;
% R*V = I
R = zeros(NumOfNode,NumOfNode);
I = zeros(NumOfNode,1);
count = 1;
for i = 1 : rowNode  % i is row
    for l = 1 : columnNode %l is column
        if(i == 1)
            if(l == 1)
                R(count,count+1) = -1;
                R(count,count+columnNode) = -1;
                R(count,count) = 3;
            elseif(l == columnNode)
                R(count,count-1) = -1;
                R(count,count+columnNode) = -1;
                R(count,count) = 3;
            else
                R(count,count+1) = -1;
                R(count,count-1) = -1;
                R(count,count+columnNode) = -1;
                R(count,count) = 4;
            end
        elseif(i == rowNode)
            if(l == 1)
                R(count,count+1) = -1;
                R(count,count-columnNode) = -1;
                R(count,count) = 3;
            elseif(l == columnNode)
                R(count,count-1) = -1;
                R(count,count-columnNode) = -1;
                R(count,count) = 3;
            else
                R(count,count+1) = -1;
                R(count,count-1) = -1;
                R(count,count-columnNode) = -1;
                R(count,count) = 4;
            end
        else
            if(l == 1)
                R(count,count+1) = -1;
                R(count,count+columnNode) = -1;
                R(count,count-columnNode) = -1;
                R(count,count) = 3;
            elseif(l == columnNode)
                R(count,count-1) = -1;
                R(count,count+columnNode) = -1;
                R(count,count-columnNode) = -1;
                R(count,count) = 3;
            else
                R(count,count+1) = -1;
                R(count,count-1) = -1;
                R(count,count+columnNode) = -1;
                R(count,count-columnNode) = -1;
                R(count,count) = 4;
            end
        end
        count = count +1;
    end
end


for i = 1 : columnNode
    I(i,1) = 1;
end

I
R
V = inv(R)*I
```


## 考試重點
### GE, LU, chol(Ax=b), QR
#### GE

#### LU
![](https://i.imgur.com/bNaRfLY.png)
#### chol(Ax=b)
見2017 3a
#### incomplete Cholesky decomposition 
處理正定對稱的sparse matrix，是Cholesky分解的近似解，通常會被拿來當作解preconditioner matrix的工具。pcg要找preconditioner matrix時可以用。可以用matlab內建的ichol或是參考以下程式碼。
```
function a = ichol(a)
	n = size(a,1);

	for k=1:n
		a(k,k) = sqrt(a(k,k));
		for i=(k+1):n
		    if (a(i,k)!=0)
		        a(i,k) = a(i,k)/a(k,k);            
		    end
		end
		for j=(k+1):n
		    for i=j:n
		        if (a(i,j)!=0)
		            a(i,j) = a(i,j)-a(i,k)*a(j,k);  
		        end
		    end
		end
	end

    for i=1:n
        for j=i+1:n
            a(i,j) = 0;
        end
    end            
end
```

#### QR
見2017 4
### NA

### EIG, exact solution

### cg & pcg
解 Ax = b, 但A必須是正定(eigen value > 0) 且對稱的實數矩陣。當A是sparse matrix時，其他分解如Cholesky可能會不適用，所以要用此方法來處理sparse matrix。
cg會有收斂問題，不但費時也可能無法收斂，所以有了preconditioned conjugate gradient。



#### 程式碼
以下是可以測試pcg和cg的matlab
```
r = 1000; %size
ra = rand(r);
A = ra * ra';

x = rand(r,1);
b = rand(r,1);


%%%%%%%%%%%%%%%
tol = 1e-8;     %tolerance
mit = 1000000;  %max iteration
%%%%%%%%%%%%%%%

tic;
[Ans1,it1] = conjgrad(A, b, x, mit,tol); % cg
toc;

tic;
[Ans2,flag,relres,it2,resvec] = pcg(A,b,tol,mit); %內建的matlab pcg
toc;

tic;
ans = inv(A) * b; % exact answer
toc;

tic;
[Ans3, it3] = cgp(x, A, speye(1), b, mit, tol, @(Z, o) Z*o, @(Z, o) o); % wiki pcg 
toc;

total = [ans,Ans1,Ans2,Ans3]
```
cg function
```
function [x,i] = conjgrad(A, b, x, mit,tol)
    r = b - A * x;
    p = r;
    rsold = r' * r;

    for i = 1:mit %length(b)
        Ap = A * p;
        alpha = rsold / (p' * Ap);
        x = x + alpha * p;
        r = r - alpha * Ap;
        rsnew = r' * r;
        if sqrt(rsnew) < tol
              break
        end
        p = r + (rsnew / rsold) * p;
        rsold = rsnew;
    end
end
```
pcg function
```
function [x, k] = cgp(x0, A, C, b, mit, stol, bbA, bbC)
% Synopsis:
% x0: initial point
% A: Matrix A of the system Ax=b
% C: Preconditioning Matrix can be left or right
% mit: Maximum number of iterations
% stol: residue norm tolerance
% bbA: Black Box that computes the matrix-vector product for A * u
% bbC: Black Box that computes:
%      for left-side preconditioner : ha = C \ ra
%      for right-side preconditioner: ha = C * ra
% x: Estimated solution point
% k: Number of iterations done 
%
% Example:
% tic;[x, t] = cgp(x0, S, speye(1), b, 3000, 10^-8, @(Z, o) Z*o, @(Z, o) o);toc
% Elapsed time is 0.550190 seconds.
%
% Reference:
%  M?todos iterativos tipo Krylov para sistema lineales
%  B. Molina y M. Raydan - {{ISBN|908-261-078-X}}
        if nargin < 8, error('Not enough input arguments. Try help.'); end;
        if isempty(A), error('Input matrix A must not be empty.'); end;
        if isempty(C), error('Input preconditioner matrix C must not be empty.'); end;
        x = x0;
        ha = 0;
        hp = 0;
        hpp = 0;
        ra = 0;
        rp = 0;
        rpp = 0;
        u = 0;
        k = 0;

        ra = b - bbA(A, x0); % <--- ra = b - A * x0;
        while norm(ra, inf) > stol
                ha = bbC(C, ra); % <--- ha = C \ ra;
                k = k + 1;
                if (k == mit), warning('GCP:MAXIT', 'mit reached, no conversion.'); return; end;
                hpp = hp;
                rpp = rp;
                hp = ha;
                rp = ra;
                t = rp' * hp;
                if k == 1
                        u = hp;
                else
                        u = hp + (t / (rpp' * hpp)) * u;
                end;
                Au = bbA(A, u); % <--- Au = A * u;
                a = t / (u' * Au);
                x = x + a * u;
                ra = rp - a * Au;
        end;
end
```
pcg function with 預設參數，可以只給 A 與 b
```=
function [x, k] = cgp(A, b, stol, mit, C, x0, bbA, bbC)
% Synopsis:
% x0: initial point
% A: Matrix A of the system Ax=b
% C: Preconditioning Matrix can be left or right
% mit: Maximum number of iterations
% stol: residue norm tolerance
% bbA: Black Box that computes the matrix-vector product for A * u
% bbC: Black Box that computes:
%      for left-side preconditioner : ha = C \ ra
%      for right-side preconditioner: ha = C * ra
% x: Estimated solution point
% k: Number of iterations done 
%
% Example:
% tic;[x, t] = cgp(x0, S, speye(1), b, 3000, 10^-8, @(Z, o) Z*o, @(Z, o) o);toc
% Elapsed time is 0.550190 seconds.
%
% Reference:
%  Métodos iterativos tipo Krylov para sistema lineales
%  B. Molina y M. Raydan - {{ISBN|908-261-078-X}}
        if nargin < 2, error('Not enough input arguments. Try help.'); end;
        if isempty(A), error('Input matrix A must not be empty.'); end;
%        if isempty(C), error('Input preconditioner matrix C must not be empty.'); end;
        if ~exist('C', 'var')
            n = size(A);
            C = speye(n(1,1));
        end
        if ~exist('x0', 'var')
            n = size(A);
            x0 = zeros(n(1,1), 1);
        end
        if ~exist('mit', 'var'), mit = 50; end;
        if ~exist('stol', 'var'), stol = 1e-6; end;
        if ~exist('bbA', 'var'), bbA = @(Z, o) Z*o; end;
        if ~exist('bbC', 'var'), bbC = @(Z, o) Z\o; end; 
        x = x0;
        ha = 0;
        hp = 0;
        hpp = 0;
        ra = 0;
        rp = 0;
        rpp = 0;
        u = 0;
        k = 0;

        ra = b - bbA(A, x0); % <--- ra = b - A * x0;
        while norm(ra, inf) > stol
                ha = bbC(C, ra); % <--- ha = C \ ra;
                k = k + 1;
                if (k == mit), warning('GCP:MAXIT', 'mit reached, no conversion.'); return; end;
                hpp = hp;
                rpp = rp;
                hp = ha;
                rp = ra;
                t = rp' * hp;
                if k == 1
                        u = hp;
                else
                        u = hp + (t / (rpp' * hpp)) * u;
                end;
                Au = bbA(A, u); % <--- Au = A * u;
                a = t / (u' * Au);
                x = x + a * u;
                ra = rp - a * Au;
        end;
        fprintf("cgp converged at iteration %d.\n", k);
```


## LTSpice使用

### 如何匯出LTSpice 的波形並匯入

1. 先按一下波形的視窗
2. 之後再按 File
![](https://i.imgur.com/QEAw3zK.png)

3. 選擇需要的輸出波形
![](https://i.imgur.com/BmPhF4o.png)

4. 如需指定輸出名稱和副檔名，可以先按Browse更改

5. 注意!!!!! 輸出後的檔案記得要將裡面的title刪掉才能讀入matlab
![](https://i.imgur.com/jBnvBbH.png)

### 如何在LTSpice中製造step function
1. 對電壓源按右鍵
2. 填入下圖資料
![](https://i.imgur.com/JSSUypC.png)

### 快捷鍵
![](https://i.imgur.com/0BEssSo.png)
**Duplicate 模式是可以圈範圍來複製整個範圍內的物件的**
![](https://i.imgur.com/77YLtpH.png)




# Class note
## 20210106

### 快速生出 (x(1)+x(2)+...+x(n))/x(1) + ... + x(n)/x(n)
```
function [f] = gen_wfunc(w_num)
    func_str = "@(x) ";
    for i = 1:w_num
        func_str = strcat(func_str, "(");
        for j = i:w_num
            func_str = strcat(func_str, sprintf("x(%d)", j));
            if j ~= w_num
                func_str = strcat(func_str, "+");
            end
        end
        func_str = strcat(func_str, sprintf(")/(x(%d))", i));
        if i ~= w_num
            func_str = strcat(func_str, " + ");
        end
    end
    f = str2func(func_str);
end
```