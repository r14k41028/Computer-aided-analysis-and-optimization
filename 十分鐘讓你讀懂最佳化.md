# 十分鐘讓你讀懂最佳化
##### tags:`課程` `最佳化` `中平`


## 2017 Fall Final
### 1. Modified nodal analysis
![](https://i.imgur.com/8ThIaMN.png)

(a)
```matlab=
clc;
clear all;
close all;
G = [ 1  0  0  0  0  0  0  1  0  0 ;
      0  1  0  0  0  0 -1 -1  0  0 ;
      0  0  2 -1  0  0 -1  0  0  0 ;
      0  0 -1  1  0  0  0  0  0  1 ;
      0  0  0  0  0  0  0  0  0 -1 ;
      0  0  0  0  0  0  0  0 -1  0 ;
      0 -1 -1  0  0  0  2  0  1  0 ;
     -1  1  0  0  0  0  0  0  0  0 ;
      0  0  0  0  0  1 -1  0  0  0 ;
      0  0  0 -1  1  0  0  0  0  0 ];
C = [ 0  0  0  0  0  0  0  0  0  0 ;
      0  2 -1  0  0  0  0  0  0  0 ;
      0 -1  1  0  0  0  0  0  0  0 ;
      0  0  0  0  0  0  0  0  0  0 ;
      0  0  0  0  1 -1  0  0  0  0 ;
      0  0  0  0 -1  2  0  0  0  0 ;
      0  0  0  0  0  0  0  0  0  0 ;
      0  0  0  0  0  0  0  1  0  0 ;
      0  0  0  0  0  0  0  0  1  0 ;
      0  0  0  0  0  0  0  0  0  1];

syms s
A = inv(G)*C;
[V,D]=eig(A);
I = eye(10);
Id = [1 0 0 0 0 0 0 0 0 0 ]';
Is = Id;
Id = Id / s;

%eigen
result = V * inv(I+s*D) * inv(V) * inv(G) * Id;
L = ilaplace(result);
figure()
ezplot(L(7),[0,10,0,1.1]); hold on


%simulate by LT Spice
load P1_with_L.txt;
X = P1_with_L(:,1);
Y = P1_with_L(:,2);
plot(X,Y); hold on


%trapezoid
VT=zeros(10,100);
x = zeros(100,1);
tsp = 0.1;
x(1)=tsp;
invC = inv(C);

for i = 1:99
    VT(:,i+1)=inv(C/tsp+0.5*G)*[Is+(C/tsp-0.5*G)*VT(:,i)];
    x(i+1)=(i+1)*tsp;
end

plot(x,VT(7,:)); hold on

%simulate by LT Spice
load P1_woL.txt;
Xwol = P1_woL(:,1);
Ywol = P1_woL(:,2);
plot(Xwol,Ywol); hold off

legend('eigen method','LTspice', 'trapezoid','LTspice W/O L')
```

### 3. Linear programming for knapsack problem.
![](https://i.imgur.com/UxQnUCd.png)
![](https://i.imgur.com/Emmo8ab.png)

P3-1.m
```matlab=
clc;
clear all;
close all;

f = [20;7;15;6;32;9;10;11;25;13];
f = -f;

intcon = 1:10;
A = [10 2 5 3 19 4 6 10 11 5;
    1 3 2 4 9 5 2 7 3 3];
b = [30;18;];
Aeq = [0,0,0,0,0,0,0,0,0,0];
beq = 0;
lb = zeros(10,1);
ub = ones(10,1);

[x,fval] = intlinprog(f,intcon,A,b,Aeq,beq,lb,ub);
-fval
```

P3-2.m
```matlab=
f = [20 7 15 6 32 9 10 11 25 13 20 7 15 6 32 9 10 11 25 13 20 7 15 6 32 9 10 11 25 13];
f = -f;
 
intcon = 1:30;
A = [10 2 5 3 19 4 6 10 11 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
     0 0 0 0 0 0 0 0 0 0 10 2 5 3 19 4 6 10 11 5 0 0 0 0 0 0 0 0 0 0;
     0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 10 2 5 3 19 4 6 10 11 5;
     1 3 2 4 9 5 2 7 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
     0 0 0 0 0 0 0 0 0 0 1 3 2 4 9 5 2 7 3 3 0 0 0 0 0 0 0 0 0 0;
     0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 3 2 4 9 5 2 7 3 3;
     1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0;
     0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0;
     0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0;
     0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0;
     0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0;
     0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0;
     0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0;
     0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0;
     0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0;
     0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1;];
b = [19;19;19;9;9;9;1;1;1;1;1;1;1;1;1;1;];
 
lb = zeros(30,1);
ub = [1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1];
[x,fval] = intlinprog(f,intcon,A,b,[],[],lb,ub);
-fval

```

## 2019 Fall Final
### 1. Moment matching
![](https://i.imgur.com/YXiO0vS.png)
![](https://i.imgur.com/Hh9Cd3y.png)


```matlab=
clear all;
close all;
clc;

G = [ 4 -1  0  0 -1  0  0  0;
     -1  4  0  0  0 -1  0  0;
      0  0  3 -1  0  0 -1  0;
      0  0 -1  3  0  0  0 -1;
     -1  0  0  0  3 -1  0  0;
      0 -1  0  0 -1  3  0  0;
      0  0 -1  0  0  0  4 -1;
      0  0  0 -1  0  0 -1  4];

C = [ 2  0 -1  0  0  0  0  0;
      0  2  0 -1  0  0  0  0;
     -1  0  2  0  0  0  0  0;
      0 -1  0  2  0  0  0  0;
      0  0  0  0  2  0 -1  0;
      0  0  0  0  0  2  0 -1;
      0  0  0  0 -1  0  2  0;
      0  0  0  0  0 -1  0  2];

Is = [1;1;0;0;0;0;0;0];
ckt_size = size(Is, 1);

nb_m = 8;
NOI = 8;
sim_time = 20;
max_step = 0.1; 
t = 0:max_step:sim_time;
iter = size(t,2);

% moment matching
m = zeros(ckt_size, nb_m);
m(:,1) = G\Is;
for i = 2:nb_m
    m(:,i) = -G\(C*m(:,i-1));
end
disp("moments");
disp(m);

% symbolic Vs
syms s
Vs = 0;
for i = 1:nb_m
    Vs = Vs + m(:,i)*s^(i-1);
end
Vn = Vs(1);
disp("symbolic function of V");
disp(Vn);

% pade
Vs_pade = pade(Vn, s, 0, 'Order', [round(nb_m/2)-1,nb_m/2]);
disp("pade approximation of V");
disp(Vs_pade);

% inverse laplace
Vt_sym = ilaplace(Vs_pade/s);
disp("Vt_sym");
disp(Vt_sym);

% simulation
Vt = zeros(1,iter);
for i = 1:iter
    Vt(1,i) = double(subs(Vt_sym, i/iter*sim_time));
end
disp("final Vt");
disp(Vt(1,iter));

plot(t, Vt);
```

### 4. nonlinear programming
![](https://i.imgur.com/smciLHz.png)

![](https://i.imgur.com/hKJscnp.png)




## Class note

### MNA例題
![](https://i.imgur.com/c35A14G.png)

Forward 確診惹
```matlab=
syms s;

plot_node = 3;
stoptime = 20;
timestep = stoptime*100;
dt = stoptime/timestep;

g = [1 1];
c = [1 1];
l = [1 1];

G = [ g(1)     0     0     0     0;
         0     0     0     1     0;
         0     0  g(2)    -1     1;
         0    -1     1     0     0;
         0     0    -1     0     0;
];

C_L = [ c(1) -c(1)     0     0     0;
       -c(1)  c(1)     0     0     0;
           0     0  c(2)     0     0;
           0     0     0  l(1)     0;
           0     0     0     0  l(2);
];

VI_cond = [1;0;1;0;0;];
t = linspace(0,stoptime,timestep);

[~,n] = size(G);

%forward
% V_fw = zeros(n,timestep);
% for i = 2:timestep
%     V_fw(:,i) = (eye(n) - dt*(C_L\G))*V_fw(:,i-1) + dt*(C_L\VI_cond);
% end

%backward
V_bw = zeros(n,timestep);
for i = 2:timestep
    V_bw(:,i) = (C_L + dt*G) \ (C_L*V_bw(:,i-1) + dt*VI_cond);
end
plot(t,V_bw(plot_node,:));
hold on;

%trapezoidal
V_tr = zeros(n,timestep);
for i = 2:timestep
    V_tr(:,i) = (C_L/dt+G/2) \ ((C_L/dt-G/2)*V_tr(:,i-1) + VI_cond);
end
plot(t,V_tr(plot_node,:));
hold on;

%eigen
[W,L] = eig(G\C_L);
V_eig = W*((eye(n)+s*L)\(W\(G\(VI_cond/s))));
V_eig = real(ilaplace(V_eig));

fplot(matlabFunction(V_eig(plot_node)), [0, 20]);
hold off;

legend("backward", "trapezoidal", "eigen");

```

### 快速生出 (x(1)+x(2)+...+x(n))/x(1) + ... + x(n)/x(n)
```matlab=
function [f] = gen_wfunc(w_num)
    func_str = "@(x) ";
    for i = 1:w_num
        func_str = strcat(func_str, "(");
        for j = i:w_num
            func_str = strcat(func_str, sprintf("x(%d)", j));
            if j ~= w_num
                func_str = strcat(func_str, "+");
            end
        end
        func_str = strcat(func_str, sprintf(")/(x(%d))", i));
        if i ~= w_num
            func_str = strcat(func_str, " + ");
        end
    end
    f = str2func(func_str);
end
```
### Euler Method

以下為推導過程 : 
![](https://i.imgur.com/zuJ7J41.png)

#### Forward
$$
\begin{align}
\mathbf{C}\frac{\mathbf{V(t_2)-V(t_1)}}{\Delta t} & = -\mathbf{GV(t_1)} + \mathbf{I_s(t_1)} \\
\mathbf{CV(t_2)}-\mathbf{CV(t_1)} &= -\Delta t \mathbf{GV(t_1)} + \Delta t \mathbf{I_s(t_1)} \\
\mathbf{CV(t_2)} &=\mathbf{CV(t_1)}-\Delta t \mathbf{GV(t_1)} + \Delta t \mathbf{I_s(t_1)} \\
\mathbf{V(t_2)} &=\mathbf{C}^{-1}[(\mathbf{C}-\Delta t \mathbf{G})\mathbf{V(t_1)} + \Delta t \mathbf{I_s(t_1)}] \\
\mathbf{V(t_2)} &= (\mathbf{I} -\Delta t \mathbf{C}^{-1}\mathbf{G})\mathbf{V(t_1)} + \Delta t \mathbf{C}^{-1} \mathbf{I_s(t_1)}
\end{align}
$$

#### Backward
$$
\begin{align}
\mathbf{C}\frac{\mathbf{V(t_2)-V(t_1)}}{\Delta t} & = -\mathbf{GV(t_2)} + \mathbf{I_s(t_2)} \\
\mathbf{CV(t_2)}-\mathbf{CV(t_1)} &= -\Delta t \mathbf{GV(t_2)} + \Delta t \mathbf{I_s(t_2)} \\
\mathbf{CV(t_2)}+\Delta t \mathbf{GV(t_2)} &=\mathbf{CV(t_1)} + \Delta t \mathbf{I_s(t_2)} \\
(\mathbf{C}+\Delta t \mathbf{G})\mathbf{V(t_2)} &=\mathbf{CV(t_1)} + \Delta t \mathbf{I_s(t_2)} \\
\mathbf{V(t_2)} &= (\mathbf{C}+\Delta t \mathbf{G})^{-1}[\mathbf{CV(t_1)} + \Delta t \mathbf{I_s(t_2)}]
\end{align}
$$


### Moment Matching

以下為推導過程 : 

![](https://i.imgur.com/9mr0vOv.png)



\begin{align}
\begin{bmatrix}
1 & 0 & 0 & 0 & 0 & 0\\
0 & 1 & 0 & -m_0 & 0 & 0 \\
0 & 0 & 1 & -m_1 &-m_0 & 0 \\
0 & 0 & 0 & -m_2 &-m_1 & -m_0 \\
0 & 0 & 0 & -m_3 &-m_2 & -m_1 \\
0 & 0 & 0 & -m_4 &-m_3 & -m_2 
\end{bmatrix}
\begin{bmatrix}
b_0 \\
b_1 \\
b_2 \\
a_0 \\
a_1 \\
a_2 \\
\end{bmatrix}
& = 
\begin{bmatrix}
m_0 \\
m_1 \\
m_2 \\
m_3 \\
m_4 \\
m_5 \\
\end{bmatrix}
\end{align}



![](https://i.imgur.com/o0ylxTw.png)



### 解方程式  (最佳解 or 整數的背包問題)

找方程式的最佳解
使用fmincon
![](https://i.imgur.com/PmzVslb.png)
![](https://i.imgur.com/FY4VlVZ.png)


解整數的背包問題
使用 intlinprog
![](https://i.imgur.com/4BWmmsj.png)
![](https://i.imgur.com/mtoOUoo.png)


## Final 2017 Spring
### 1.MNA
![](https://i.imgur.com/Szm8t6Z.png)
![](https://i.imgur.com/zSGKN9j.png)
![](https://i.imgur.com/2kKPn41.png)
https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=712097&tag=1

#### a.eigenvector method
```
G = [1 0 0 0 0 -1 1 0 0 0 0;
    0 1 -1 0 0 0 -1 0 0 0 0;
    0 -1 1 0 0 0 0 1 0 0 0;
    0 0 0 0 0 0 0 -1 1 0 0;
    0 0 0 0 1 0 0 0 -1 1 0;
    -1 0 0 0 0 1 0 0 0 0 1;
    -1 1 0 0 0 0 0 0 0 0 0;
    0 0 -1 1 0 0 0 0 0 0 0;
    0 0 0 -1 1 0 0 0 0 0 0;
    0 0 0 0 -1 0 0 0 0 0 0;
    0 0 0 0 0 -1 0 0 0 0 0;];
C = [0 0 0 0 0 0 0 0 0 0 0;
    0 2 0 -1 0 0 0 0 0 0 0;
    0 0 0 0 0 0 0 0 0 0 0;
    0 -1 0 2 0 0 0 0 0 0 0;
    0 0 0 0 1 0 0 0 0 0 0;
    0 0 0 0 0 0 0 0 0 0 0;
    0 0 0 0 0 0 1 0 0 0 0;
    0 0 0 0 0 0 0 1 0 0 0;
    0 0 0 0 0 0 0 0 1 0 0;
    0 0 0 0 0 0 0 0 0 0 0;
    0 0 0 0 0 0 0 0 0 0 0;];
syms s t
A = inv(G)*C;
[V,D]=eig(A);
I = eye(11);
Id = [0 0 0 0 0 0 0 0 0 -1 -1]';
Id = Id/s


result = V * inv(I+s*D) * inv(V) * inv(G) * Id;
L = ilaplace(result);
f = L(4);

x=0:0.1:20;
y=[];
for i=0:0.1:20
    y(end+1) = real(double(subs(f, t, i)));
end
plot(x,y,'k'); hold on


%simulate by LT Spice
LTspice = readmatrix('2017springFinal_p1.txt','NumHeaderLines',0);
X = LTspice(:,1);
Y = LTspice(:,2);
plot(X,Y,'r')
```

#### b.forward Euler method

<font color="#f00">Warning</font>: Mtrix C is singular, so the code is not working.
```
I = [1 0 0 1].';
v = [0 0 0 0].';

y = [0];
step = 0.1;
x=0:step:20;
for i=step:step:20
    v2=(eye(4)-step*inv(C)*G)*v+step*inv(C)*I;
    y(end+1)=v2(4);
    v=v2;
end
```


#### c.backward Euler method
```
G = [1 0 0 0 0 -1 1 0 0 0 0;
    0 1 -1 0 0 0 -1 0 0 0 0;
    0 -1 1 0 0 0 0 1 0 0 0;
    0 0 0 0 0 0 0 -1 1 0 0;
    0 0 0 0 1 0 0 0 -1 1 0;
    -1 0 0 0 0 1 0 0 0 0 1;
    -1 1 0 0 0 0 0 0 0 0 0;
    0 0 -1 1 0 0 0 0 0 0 0;
    0 0 0 -1 1 0 0 0 0 0 0;
    0 0 0 0 -1 0 0 0 0 0 0;
    0 0 0 0 0 -1 0 0 0 0 0;];
C = [0 0 0 0 0 0 0 0 0 0 0;
    0 2 0 -1 0 0 0 0 0 0 0;
    0 0 0 0 0 0 0 0 0 0 0;
    0 -1 0 2 0 0 0 0 0 0 0;
    0 0 0 0 1 0 0 0 0 0 0;
    0 0 0 0 0 0 0 0 0 0 0;
    0 0 0 0 0 0 1 0 0 0 0;
    0 0 0 0 0 0 0 1 0 0 0;
    0 0 0 0 0 0 0 0 1 0 0;
    0 0 0 0 0 0 0 0 0 0 0;
    0 0 0 0 0 0 0 0 0 0 0;];



I = [0 0 0 0 0 0 0 0 0 -1 -1].';
v = [0 0 0 0 0 0 0 0 0 0 0].';


ans = [0];
step = 0.001;
t=0:step:20;
for i=step:step:20
    v2=inv(C+step*G)*(C*v+step*I);
    ans(end+1)=v2(4);
    v=v2;
end
plot(t,ans); hold on


%simulate by LT Spice
LTspice = readmatrix('2017springFinal_p1.txt','NumHeaderLines',0);
X = LTspice(:,1);
Y = LTspice(:,2);
plot(X,Y,'r')


```

#### d.trapezoidal method
```
G = [1 0 0 0 0 -1 1 0 0 0 0;
    0 1 -1 0 0 0 -1 0 0 0 0;
    0 -1 1 0 0 0 0 1 0 0 0;
    0 0 0 0 0 0 0 -1 1 0 0;
    0 0 0 0 1 0 0 0 -1 1 0;
    -1 0 0 0 0 1 0 0 0 0 1;
    -1 1 0 0 0 0 0 0 0 0 0;
    0 0 -1 1 0 0 0 0 0 0 0;
    0 0 0 -1 1 0 0 0 0 0 0;
    0 0 0 0 -1 0 0 0 0 0 0;
    0 0 0 0 0 -1 0 0 0 0 0;];
C = [0 0 0 0 0 0 0 0 0 0 0;
    0 2 0 -1 0 0 0 0 0 0 0;
    0 0 0 0 0 0 0 0 0 0 0;
    0 -1 0 2 0 0 0 0 0 0 0;
    0 0 0 0 1 0 0 0 0 0 0;
    0 0 0 0 0 0 0 0 0 0 0;
    0 0 0 0 0 0 1 0 0 0 0;
    0 0 0 0 0 0 0 1 0 0 0;
    0 0 0 0 0 0 0 0 1 0 0;
    0 0 0 0 0 0 0 0 0 0 0;
    0 0 0 0 0 0 0 0 0 0 0;];



I = [0 0 0 0 0 0 0 0 0 -1 -1].';
v = [0 0 0 0 0 0 0 0 0 0 0].';

ans = [0];
step = 0.1;
t=0:step:20;
for i=step:step:20
    v2=inv(2*C+step*G)*(2*C*v-step*G*v+step*I+step*I);
    ans(end+1)=v2(4);
    v=v2;
end
plot(t,ans,'k'); hold on



%simulate by LT Spice
LTspice = readmatrix('2017springFinal_p1.txt','NumHeaderLines',0);
X = LTspice(:,1);
Y = LTspice(:,2);
plot(X,Y,'r')
```

#### e. moment matching 
```
clear all;
close all;
clc;

G = [1 0 0 0 0 -1 1 0 0 0 0;
    0 1 -1 0 0 0 -1 0 0 0 0;
    0 -1 1 0 0 0 0 1 0 0 0;
    0 0 0 0 0 0 0 -1 1 0 0;
    0 0 0 0 1 0 0 0 -1 1 0;
    -1 0 0 0 0 1 0 0 0 0 1;
    -1 1 0 0 0 0 0 0 0 0 0;
    0 0 -1 1 0 0 0 0 0 0 0;
    0 0 0 -1 1 0 0 0 0 0 0;
    0 0 0 0 -1 0 0 0 0 0 0;
    0 0 0 0 0 -1 0 0 0 0 0;];
C = [0 0 0 0 0 0 0 0 0 0 0;
    0 2 0 -1 0 0 0 0 0 0 0;
    0 0 0 0 0 0 0 0 0 0 0;
    0 -1 0 2 0 0 0 0 0 0 0;
    0 0 0 0 1 0 0 0 0 0 0;
    0 0 0 0 0 0 0 0 0 0 0;
    0 0 0 0 0 0 1 0 0 0 0;
    0 0 0 0 0 0 0 1 0 0 0;
    0 0 0 0 0 0 0 0 1 0 0;
    0 0 0 0 0 0 0 0 0 0 0;
    0 0 0 0 0 0 0 0 0 0 0;];

Is = [0 0 0 0 0 0 0 0 0 -1 -1].';
ckt_size = size(Is, 1);

nb_m = 10;
sim_time = 20;
max_step = 0.1; 
t = 0:max_step:sim_time;
iter = size(t,2);

% moment matching
m = zeros(ckt_size, nb_m);
m(:,1) = G\Is;
for i = 2:nb_m
    m(:,i) = -G\(C*m(:,i-1));
end
disp("moments");
disp(m);

% symbolic Vs
syms s
Vs = 0;
for i = 1:nb_m
    Vs = Vs + m(:,i)*s^(i-1);
end
Vn = Vs(4);
disp("symbolic function of V");
disp(Vn);

% pade
Vs_pade = pade(Vn, s, 0, 'Order', [round(nb_m/2)-1,nb_m/2]);
disp("pade approximation of V");
disp(Vs_pade);

% inverse laplace
Vt_sym = ilaplace(Vs_pade/s);
disp("Vt_sym");
disp(Vt_sym);

% simulation
Vt = zeros(1,iter);
for i = 1:iter
    Vt(1,i) = double(subs(Vt_sym, i/iter*sim_time));
end
disp("final Vt");
disp(Vt(1,iter));

plot(t, Vt); hold on

%simulate by LT Spice
LTspice = readmatrix('2017springFinal_p1.txt','NumHeaderLines',0);
X = LTspice(:,1);
Y = LTspice(:,2);
plot(X,Y,'r')


```


651531351531
```
abc 01> r exp_TCAD/collapse/benchmark/iscas_itc/s38417.blif
abc 02> tl_syn
abc 04> mtlsv
abc 05> pt
abc 07> q

```